#
# backup protocol definition
#

Name 				Backup
IdentString			Box-Backup:v=C
ServerContextClass	BackupStoreContext	BackupStoreContext.h

AddType		Filename	BackupStoreFilenameClear	BackupStoreFilenameClear.h
AddType		String		std::string

ImplementLog	Server	syslog
ImplementLog	Client	syslog
ImplementLog	Client	file

LogTypeToText	Filename	"%s"	VAR.GetClearFilenameIfPossible("OPAQUE").c_str()

BEGIN_OBJECTS

# -------------------------------------------------------------------------------------
#  Session commands
# -------------------------------------------------------------------------------------

Error		0	IsError(Type,SubType)	Reply
	int32		Type
	int32		SubType
	CONSTANT	ErrorType						1000
	CONSTANT	Err_WrongVersion				1
	CONSTANT	Err_NotInRightProtocolPhase		2
	CONSTANT	Err_BadLogin					3
	CONSTANT	Err_CannotLockStoreForWriting	4
	CONSTANT	Err_SessionReadOnly				5
	CONSTANT	Err_FileDoesNotVerify			6
	CONSTANT	Err_DoesNotExist				7
	CONSTANT	Err_DirectoryAlreadyExists		8
	CONSTANT	Err_CannotDeleteRoot			9
	CONSTANT	Err_TargetNameExists			10
	CONSTANT	Err_StorageLimitExceeded		11
	CONSTANT	Err_DiffFromFileDoesNotExist	12
	CONSTANT	Err_DoesNotExistInDirectory		13
	CONSTANT	Err_PatchConsistencyError		14
	CONSTANT	Err_MultiplyReferencedObject		15
	CONSTANT	Err_DisabledAccount				16

Version		1	Command(Version)	Reply
	int32	Version


Login		2	Command(LoginConfirmed)
	int32		ClientID
	int32		Flags
	CONSTANT	Flags_ReadOnly	1


LoginConfirmed	3	Reply
	int64		ClientStoreMarker
	int64		BlocksUsed
	int64		BlocksSoftLimit
	int64		BlocksHardLimit


Finished	4	Command(Finished)	Reply	EndsConversation


# generic success object
Success		5	Reply
	int64		ObjectID


SetClientStoreMarker	6	Command(Success)
	int64		ClientStoreMarker


# -------------------------------------------------------------------------------------
#  Generic object commands
# -------------------------------------------------------------------------------------

GetObject	10	Command(Success)
	int64		ObjectID
	# reply has stream following (if successful)


MoveObject	11	Command(Success)
	int64		ObjectID
	int64		MoveFromDirectory
	int64		MoveToDirectory
	int32		Flags
	Filename	NewFilename
	
	CONSTANT Flags_MoveAllWithSameName			1
	CONSTANT Flags_AllowMoveOverDeletedObject	2

# consider this an object command as, although it deals with directory entries,
# it's not specific to either a file or a directory


GetObjectName	12	Command(ObjectName)
	int64		ObjectID
	int64		ContainingDirectoryID
	CONSTANT	ObjectID_DirectoryOnly	0

	# set ObjectID to ObjectID_DirectoryOnly to only get info on the directory


ObjectName		13	Reply
	int32		NumNameElements
	int64		ModificationTime
	int64		AttributesHash
	int16		Flags
	# NumNameElements is zero if the object doesn't exist
	CONSTANT	NumNameElements_ObjectDoesntExist	0
	# a stream of Filename objects follows, if and only if NumNameElements > 0


# -------------------------------------------------------------------------------------
#  Directory commands
# -------------------------------------------------------------------------------------

CreateDirectory	20	Command(Success)	StreamWithCommand
	int64		ContainingDirectoryID
	int64		AttributesModTime
	Filename	DirectoryName
	# stream following containing attributes


ListDirectory	21	Command(Success)
	int64		ObjectID
	int16		FlagsMustBeSet
	int16		FlagsNotToBeSet
	bool		SendAttributes
	# make sure these flags are synced with those in BackupStoreDirectory
	CONSTANT	Flags_INCLUDE_EVERYTHING 	-1
	CONSTANT	Flags_EXCLUDE_NOTHING 		0
	CONSTANT	Flags_EXCLUDE_EVERYTHING	15
	CONSTANT	Flags_File			1
	CONSTANT	Flags_Dir			2
	CONSTANT	Flags_Deleted			4
	CONSTANT	Flags_OldVersion		8
	# make sure this is the same as in BackupStoreConstants.h
	CONSTANT	RootDirectory			1

	# reply has stream following Success object, containing a stored BackupStoreDirectory


ChangeDirAttributes	22	Command(Success)	StreamWithCommand
	int64		ObjectID
	int64		AttributesModTime
	# stream following containing attributes


DeleteDirectory	23	Command(Success)
	int64		ObjectID


UndeleteDirectory	24	Command(Success)
	int64		ObjectID
	# may not have exactly the desired effect if files within in have been deleted before the directory was deleted.


CreateDirectory2	25	Command(Success)	StreamWithCommand
	int64		ContainingDirectoryID
	int64		AttributesModTime
	int64		ModificationTime
	Filename	DirectoryName
	# stream following containing attributes


# -------------------------------------------------------------------------------------
#  File commands
# -------------------------------------------------------------------------------------

StoreFile	30	Command(Success)	StreamWithCommand
	int64		DirectoryObjectID
	int64		ModificationTime
	int64		AttributesHash
	int64		DiffFromFileID		# 0 if the file is not a diff
	Filename	Filename
	# then send a stream containing the encoded file


GetFile		31	Command(Success)
	int64		InDirectory
	int64		ObjectID
	# error returned if not a file, or does not exist
	# reply has stream following, containing an encoded file IN STREAM ORDER
	# (use GetObject to get it in file order)


SetReplacementFileAttributes	32	Command(Success)	StreamWithCommand
	int64		InDirectory
	int64		AttributesHash
	Filename	Filename
	# stream follows containing attributes


DeleteFile	33	Command(Success)
	int64		InDirectory
	Filename	Filename
	# will return 0 if the object couldn't be found in the specified directory


GetBlockIndexByID	34	Command(Success)
	int64		ObjectID

	# stream of the block index follows the reply
	# returns an error if the object didn't exist


GetBlockIndexByName	35	Command(Success)
	int64		InDirectory
	Filename	Filename

	# Success object contains the found ID -- or 0 if the entry wasn't found in the directory
	# stream of the block index follows the reply if found ID != 0


UndeleteFile	36	Command(Success)
	int64		InDirectory
	int64		ObjectID
	# will return 0 if the object couldn't be found in the specified directory


# -------------------------------------------------------------------------------------
#  Information commands
# -------------------------------------------------------------------------------------

GetAccountUsage	40	Command(AccountUsage)
	# no data members

AccountUsage	41	Reply
	int64	BlocksUsed
	int64	BlocksInOldFiles
	int64	BlocksInDeletedFiles
	int64	BlocksInDirectories
	int64	BlocksSoftLimit
	int64	BlocksHardLimit
	int32	BlockSize

GetIsAlive	42	Command(IsAlive)
	# no data members

IsAlive	43	Reply
	# no data members

GetAccountUsage2	44	Command(AccountUsage2)
	# no data members

AccountUsage2	45	Reply
	String	AccountName
	bool	AccountEnabled
	int64	ClientStoreMarker
	int32	BlockSize
	int64	LastObjectIDUsed
	int64	BlocksUsed
	int64	BlocksInCurrentFiles
	int64	BlocksInOldFiles
	int64	BlocksInDeletedFiles
	int64	BlocksInDirectories
	int64	BlocksSoftLimit
	int64	BlocksHardLimit
	int64	NumCurrentFiles
	int64	NumOldFiles
	int64	NumDeletedFiles
	int64	NumDirectories


# -------------------------------------------------------------------------------------
#  Snapshot Commands
# -------------------------------------------------------------------------------------

# Creates a new reference to an existing object ID, with a new name, in the
# specified directory (by object ID). The object pointed to by this new
# reference will then have at least two references, and therefore be immutable.
# However these operations are still possible:
#
# * Rename and delete from one of its (2+) containers, if that container is not
# also immutable;
#
# * Modify by uploading a patch if it's a file, which creates a new object with
# a new ID doesn't logically change the object with this ID, even if its
# contents are converted to a reverse diff in the process;
# 
# * Copy, which changes its object ID to a new copy that initially has no
# references, but will presumably have one when inserted into the relevant
# container, and will thus be modifiable.

AddReference	50	Command(Success)
	int64		ObjectToCloneID
	int64		OldDirectoryID
	int64		NewDirectoryID
	Filename	NewObjectFileName

# Find the directory named by ObjectFileName in ContainingDirID, and ensure
# that it is unique/singly referenced, copying it if necessary.
#
# If the directory is mirrored (multiply referenced), then make a copy of it,
# adjust the directory entry named ObjectFileName in ContainingDirID to point
# to the new copy, and return the ID of the new copy, which is now singly
# referenced and therefore modifiable again. Note that this is not recursive:
# the newly copied directory contains the same entries as the original, and
# thus adds a reference to each one of them, making them mirrored.
#
# The containing directory must already be unique. The root directory is
# always unique.
#
# If the directory is already unique (singly referenced), then no copy will be
# made and its existing object ID will be returned.

MakeUnique	51	Command(Success)
	int64		ObjectToMakeUniqueID
	int64		ContainingDirID

DeleteNow	52	Command(Success)
	int64		ObjectToDeleteID
	int64		ContainingDirID
	# will return an error if the object couldn't be found in the specified directory


