TITLE Forms

Forms are the basic means of interaction with the user, other than clicking on links with embedded parameters. There can be more than one form per page, each with a one character ID unique within the page.

The form Unit writes two bits of code, the HTML for the form and the code to handle that form. These can be separated, so that one page outputs the form and another handles it (the ID for the form must be the same on both pages).

This is useful for global forms, such as search boxes, have optimisations which result in simple HTML with no variable subsitution being output if the default state of the form is always constant. (They could be implemented in another way, where the form handler redirects to a different page, but this seems somewhat messy, even if the page definition scripts themselves are neat through Unit reuse.)

Separating forms and actions is not suitable for all forms, as it complicates the error case: When the user enteres bad information, the form is returned with the data the user entered, plus visual markers on the fields which caused the form to be rejected.

As there can be more than one form per page, it is necessary to determine which form was submitted. In each form, there is an additional hidden variable, '<ID>_s', and the automatically generated scripts use this to select the form handler to call.


SUBTITLE Form structure

The Form Unit acts as the parent for other classes which generate the actual form HTML. When writing code and HTML, it outputs sub-units in alphabetic order (strictly perl sort() order), without any adornment. This allows complete flexibility in how forms are laid out.

A single form data object is written, which contains converted data members for all the fields, and appropraite accessor functions. This class also has a member function which reads the data from the HTTP request.

Typically, fields will live in a table to line them up nicely. Instances of a sub-class of TableContainer, FormTableContainer, can be created automatically with the make_container() methods. This Unit has various utility methods for for creating common field types -- but these don't have to be used. Adding FormItem units manually is just as good.


SUBTITLE Accessing form data

A data class is generated, called <AppName>Form<FormName>, where FormName has the first letter capitalised.

Each form item has a name. If this was Item, the data class object would have a member variable mItem, and a GetItem() accessor function.

Page variables are registered under the form name, so if the form is named 'input' and a field is 'Item', it can be used anywhere which acccepts a page variable as 'input.Item'.


SUBTITLE Validation

Each member variable of the form object has a corresponding ValidityError variable (unless the FormItem has no validation), and a NameValid() function to determine whether or not it was valid. In general, the FormItems can write all the validation code necessary, and output appropriate error messages.

ValidityErrors allow for a validation failure to output different errors in different circumstances. Most will only have one error, though.

To add extra validation for when the standard validation doesn't quite do enough, set the FormValidation variable. If set to none, then nothing extra is done. If set to simple or errorgen, you will need to implement an extra Validate() function for the data object class. This is free to set any of the ValidityError variables as required.

If FormValidation is errorgen, then the Validate() function can also output additional error messages, for example, when an error affects more than one field. Use AddError(const char *) to add an error message. To access the translated string table for the current language and current page, call GetTranslatedStrings() (see Translations.txt for more details.)

If the validation function requires access to other objects, for example, the Application object to access to the database connection, then it can specify arguments using the ArgsToValidate attribute of the Form object. This is a space separated list (or anon array) of objects, currently Application, Request and Response, or any page variable. They are passed in order as references of the appropraite type. See the function prototype generated by the Unit. Note that the use of the '=type name' notation for page variables allows you to pass in anything, but you must use the anon array method. For example

	'ArgsToValidate' => ['Application', '=std::string localVar']

If the validation function wishes to make available by-products of the validation process to the rest of the page, use WebAppFramework::Unit::FormItem::ExtraDataMember to create an extra member variable. (see FormItems.txt)


SUBTITLE Conditional items

Form items (and units containing items as subunits) can be made conditional at runtime on C++ expressions. This allows the same form code to be used for two purposes, or adapt a form's content at runtime.

Different conditions can be used for different form items.

After the form is completely assembled, the conditional_items() should be called. This takes a C++ expression, followed by pairs of items and their replacement units (or text for translation). For example:

	$optform->conditional_items('params.GetFormShow() != 1',
		'B' => undef,
		$unit_reference => 'not shown');

If the first in the pair is a string, then it refers to an item. If it is a reference, then it is a reference to any unit in the heirarchy below the form. All form items within it will be made optional.

This function modifies the heirarchy, replacing the fields with appropraite OutputIf units. It also modifies the validation code to only require the fields if they are shown.

The C++ expression is only executed once.

This mechanism could be subverted to output different fields for different languages by having the expression dependent on language.


SUBTITLE Handling forms

When the form is submitted and all validation has been run, code can be written to perform an action. This is run in the "preparation" phase, so the standard process and redirect method can be used.

To add code to be run, use the HandleSubmission attribute. This can either be a string to output as code, or a reference to a function which will write it. This will be called with parameters (ref to page, ref to form, output), and is free to output code or text.

To perform a redirect, use make_redirect_code(link) on a Unit object. This will return a string containing the necessary code, which will only work in a handler function before the output has started being generated.


SUBTITLE Form Unit

This is a subclass of FragmentTemplate. The following atttributes are accepted:

FormName - name of form (conventionally beginning with a lower case letter)
FormID - one letter ID (only necessary if target is not this page)
ExternalErrors - if present, then errors are displayed external to the form
HandleSubmission - code to handle a validated submission, or ref to function to write it.
FormValidation - style of validation: none, simple, errorgen
ArgsToValidate - arguments the validation function expects (see above)
PostSetAndValidateCode - optional, code which is output just after the form object is read and validated.
ErrorDisplayCondition - C++ condition for displaying the error display box (the one by default above the form) If 'false', the code is not output.

As a FragmentTemplate, it expects the following fragments

* ErrorMarker -- displayed after a field if it wasn't a valid response. If the string is empty (no text within markers in template file), then no error markers will be displayed (no code for this generated)

* InlineErrorStart -- if inline errors are used, the HTML to display before the text message.

* InlineErrorEnd -- if inline errors are used, the HTML to display after the text error message.

* ErrorStart -- used for both inline and external error displays, as the start of the error message.

* ErrorListStart, ErrorListSeparate, ErrorListEnd -- used to separate the list of items when displaying errors externally.


These fragments are largely just required for defaults when classes further down the heirarchy can't provide them. Generally just use the same Template and fragment names as FormTableContainer in set_defaults().


SUBTITLE Error display

The form will, by default, display an error message just before the <form> tag. This may not be quite what is required.

It can be placed anywhere on the page by using the FormErrorDisplay unit. Create one like this

  WebAppFramework::Unit::FormErrorDisplay->new('Form' => $form)

where $form is a reference to the form unit, and then add it normally anywhere in the page.


SUBTITLE FormItem Unit

Fields are units too, and could potentially emit multiple HTML form inputs. See also FormItems.txt, for a list and details of implemented fields, and WritingFormItems.txt for details on how to implement fields.

Every field must be derived from FormField, and expects at least the following attributes:

Name - Form item name


Attributes relating to validation are:

Label - Label, subject to translation. Used for automatically generating error messages
Validation - Validation information
ValidationFailMsg - Text to display when validation fails


Additionally, some fields may support these attributes 

Attributes - Extra tags for items, eg 'class="css_style"'. Will be applied to the main tags for the form elements.



SUBTILE FormTableContainer Unit

This is a subclass of FragmentTemplate. It expects the following fragments

* ErrorMarker -- displayed after a field if it wasn't a valid response

It provides the following utility functions:

add_text_field(field_name, label, validation, @specification)
	- if label is the empty string, no label is set
	- if validation is the empty string, no validation is set

add_submit_button(field_name, button_text, @specification)

add_checkbox(field_name, label, @specification)

add_number_field(field_name, label, validation, default_number, blank_value, @specification)
	- default_number should only be displayed when the number is outside the normal int32_t range
	- if blank_value ne '', then blank entries are allowed, and the field will be set to this value

add_choice(field_name, label, choices/ref to data source, style, validation, default, @specification)
	- default not included if it is ''.
	(see form items for more info)

add_item(field_name, label, unit)
	- adds an arbitary unit as a field

