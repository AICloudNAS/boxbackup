TITLE Autogenerated query objects

Perl scripts write query objects for even neater database queries. SQL statments and their use can be separated from the code into separate files, and/or included inline in the cpp files.


SUBTITLE Schema files

Schema files contain all the SQL commands necessary to set up a database -- not just CREATE TABLE commands. Each command must be ; terminated. Comments are started by # and continue to the end of the file.

makedbcreate.pl will then generate two functions -- a create function which executes all these SQL queries, and a drop function which DROPs all the tables created.

makedbcreate.pl input.schema output.cpp output.h

The functions will be called input_Create(db) and input_Drop(db) (where input.schema is the name of the schema file).

It is recommended that the makedbmake.pl script is used to generate the makefile which will run this, see below.


SUBTITLE Query definition

Queries look like this

SQL Query
[
	Name: Test2
	Statement: SELECT fInteger,fString FROM tTest1 WHERE fInteger=$1 AND fString=$2
	Parameters: int, std::string StringParam NULL?
	Results: int Integer, std::string String
]

and may appear anywhere in a .query or .cpp file. The lines are of the form "Attribute: Value", where Value may extend over multiple lines.

Name - specifies the name of the C++ class generated.

Statement: The SQL statement, with $n insertation markers.

Parameters: Types and optional names of the parameters (corresponding to insertation markers)

Results: Types and names of the results.

Flags: Options. Only one at the moment is SingleValue.

AutoIncrementValue: (see below)


If the type and name of a result or parameter is followed by the string NULL?, then this means that item might be null. For parameters, this means the parameter is passed in by a pointer (so that it can be NULL), and for results, means a Is<Name>Null() function is generated.

Types should be std::string, int or int32_t.

If the SingleValue option is set, then an additional static Do() function is generated, which given a database connection and the parameters, executes the query and returns the single value. Note the Results still must be set, to obtain the type of the result value.


SUBTITLE Runtime statments

If the statement is the string "runtime", then the generated class will be derived off DatabaseQueryGeneric, and the statement can be specified at runtime.

This is useful for when exact WHERE clauses are not known until runtime, but the results from the query are known.


SUBTITLE Query objects for other code generation systems

Other code generation systems (for example, the web application framework) may use batabase query objects. To create one, do

my $query = Database::Query->new('Name' => 'Test2', 'Statement' => 'SQL', ...);

where the parameters are the attributes as in the query definition above.


SUBTITLE Auto-incrementing fields

If the

	AutoIncrementValue: TableName ColumnName

attribute is set, then the autogenerated query will have an InsertedID() method, which will return the auto-incremented value (see AutoIncrement.txt). In addition, a Do() method will be generated, which will return this value.


SUBTITLE Using an autogenerated query

The constructor of the autogenerated class just takes a reference to the DatabaseConnection object. The Execute() function takes typed parameters as described in the "Parameters" attribute. Other than that, it's used exactly as any other query object, except that field values are obtained by Get<Name>() functions, rather than generic field functions referencing the column number.

The benefits over DatabaseQueryGeneric are:

1) Named query, with SQL moved away from the actual code to the definition of the query.

2) It is possible to completely separate the database storage and the SQL from C++ code.

3) One-shot "single result value" queries have a static one-line Do() function.

4) Parameters to Execute and Do() are strongly typed, and when multiple parameters are used, less clumsy to specify with the type string.

5) Names of the fields are used instead of generic field retrieval functions with column numbers.

6) Auto-incrementing fields are handled in a neater way.


SUBTITLE Setting up

Include the following lines in the Makefile.extra file:

========================================================================
# AUTOGEN SEEDING
autogen_db/testdb_schema.cpp:	testdb.schema
	../../lib/database/makedbmake.pl .

# include-makefile: Makefile.db
========================================================================

(assuming you have a schema file, otherwise, use a query file)

This will setup a makefile which will

1) For every .query file in the directory, autogenerate queries from it in the simiarly named files within autogen_db.

2) For every .cpp file which contains SQL Query sections, generate files withing autogen_db called name_query.h/cpp where the file is called 'name.cpp'.

So, to use the queries within name.queries, include "autogen_db/name.h" in your cpp file, where the query file is called "name.query'.

To use statements included in your cpp file, include "autogen_db/name_query.h" in your cpp file, where that cpp file is called name.cpp.

