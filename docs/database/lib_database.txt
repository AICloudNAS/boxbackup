TITLE lib/database

Provides a generic interface to a number of database servers.

Design aims:

* totally consitent across databases: abstract away differences in API and SQL

* efficient

* easy to use
	* parameters in query strings
	* repeated queries with different values
	* creation and destruction of backend objects happens automatically.

* autogeneration of code, as well as simple in-line SQL
	* use knowledge of scheme to deduce types and do type checking

* errors reported by exceptions only (so write code on assumption of success)

For an example of usage, see test/database/testdatabase.cpp


SUBTITLE Connecting to a database

The DatabaseConnection object represents a connection to the database, which is connected when the Connect() method is called, and disconnected when the object is destroyed. For example

DatabaseConnection db;
db.Connect(std::string("sqlite"), connectionString, 1000 /* timeout in ms */);

This will either connect or exception.

The first parameter is the driver name. The drivers available depend on what is compiled into the application (based on what was available when the code was compiled).

The second is the connection string, which is driver dependent, and specifies everything the driver needs to know to make the connection. For database servers, this is hostname, username, password and database name, for SQLite it's simply the filename of the database.

The Timeout is the connection timeout, in milliseconds. Some drivers may interpret this slightly differently, but all in an appropraite manner.



SUBTITLE Making a query

The DatabaseQuery object makes a query to the database. By itself, it cannot do anything useful, and a derived class must be used (for example, DatabaseQueryGeneric).

Applications should not generate SQL statements at runtime. Instead, a system of parameters is used to efficiently insert variable data into SQL. For example

  INSERT INTO table (field1,field2) VALUES ($1,$2)

The SQL statement is constant, but at runtime, the two values $1 and $2 are passed as arguments to the Execute() function. Strings need not be quoted. NULL values are passed as NULL pointers instead of pointers to an actual value.

The exact way arguments are presented depends on the derived class -- in general, the derived class will have an Execute method which allows for type-safe arguments (mainly with autogenerated code).

The same query can be executed many times, with different arguments. Some drivers will handle this very efficiently if the statement can be "prepared".

Once the query has been executed, the results can be read.

If the query does not return data (eg an INSERT statement), then GetNumberChanges() will return the number of changes made.

Otherwise, data must be retrieved. GetNumberRows() and GetNumberColumns() return the number of rows and columns respectively.

To read all the fields out, use a loop like

while(query.Next())
{
	// handle row
}

Within the loop, use GetFieldInt() and GetFieldString() with the column number to retrieve row values. (Given the database overhead, it is recommended that if a value is used repeatly, the GetField*() method is only called once, with the value stored in a local variable.)

With autogenerated code, suitable GetFieldName() functions will be generated, which return named fields.

If the query returns a dataset of 1 row and 1 column exactly, then GetSingleValueInt() and GetSingleValueString() can be used to retrieve that one value without the necessity to call Next(). This is provided for convienence.


SUBTITLE Generic query object

DatabaseQueryGeneric is a generic query object which can be used for simple queries where it's not worth using autogenerated code.

The basic SQL statement is passed into the constructor, and then several Execute methods are provided; no parameters, 1 int or string parameter, or many parameters.

The many parameters method is declared as

	void Execute(const char *Types, ...)

The first argument specifies the type of the following arguments, and implied by the length of the string, the number of arguments. Little type checking can be done -- for complex queries taking many arguments, use autogenerated code! (Or where there are many columns to return, where it's nicer to use names than numbers to refer to them.)

Each character in the string defines one argument. Values are

i = integer (value, cannot be NULL)
I = integer (pointer, can be null)
s = const char * string (pointer, can be NULL)
S = std::string (pointer, can be null)
N = null (corresponding argument must be NULL or 0)

For example,

int i1 = 24;
char *str1 = "test string";
std::string str2("Test string 2");
query.Execute("NiIIsssSS", NULL, 56, NULL, &i1, NULL, "constant string", str1,
   NULL, &str2);

Values are read out as any other DatabaseQuery object.
